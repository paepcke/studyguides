4.2
slide
Compilers Code Generation II E
This video is a continuation of the previous video where we&#39;ll be finishing up co-generation for the simple language dealing with function calls, function 

12.87
slide
Code Generation l Code for function calls and fungioLdinm depends on the layout of the AR A very simple AR suffices for this language The result is always in the accumulator No need to store the result in the AR The activation record holds actual parameters For f x1 l push 1 H l on the stack These are the only variables in this language my mm
definitions and variable references. So just to remind you what we&#39;re working on, 

20.47
slide
Code Generation The stack discipline guarantees that on function exit ER is the same as it was on function entry No need for a control link We need the return address A pointer to the current activation is useful This pointer lives in frame pointer


20.47
slide
Summary For this language an AR with the frame Code Generation pointer the actual parameters and the return address suffices Picture Considera call to f x y the AR is FP SP old fp AR off Alex Nken
here is the simple language And again, we have a bunch of different kinds of 

24.099
slide
Code Generation l The callin se u is the instructions of both I caller and callee to set up a function invocation 4 L New instruction jal label Jump to label save address of next instruction in m On other architectures the return address is stored on the stack by the call instruction My Man
expressions And we dealt with all of these last time except for variable references 

30.059
slide
cgen f en sw Sfp 0 addiu 55p 55p 4 cgen en SW 530 0 sp Code Generation
and function calls And of course, we also have function definitions. So, as I said 

34.5
slide
J1 cge 21I en l SW SW Olgp addiu Ssp 55p 4 cgen en sw 30 0 sp addiu sp 55p 4 egenlel sw a0 0 sp ad u Ssp Ssp 4 a entr Code Generation The caller saves its value of the frame pointer Then it saves the actual parameters in reverse order Finally the caller saves the return address in register ra The AR so far is 4 n 4 bytes long my mm
in the introduction these are the three constructs we&#39;ll be looking at in this video. &gt;&gt; The main issue in designing the co-generation for function calls and 

44.7
slide
Code Generation ll New instruction reg Jump to address in register reg cgen def f x1 xn e 4 W anove Sfp 55p 5w Sra 0155 13 My Man


44.7
slide
Code Generation New instruction reg Jump to address in register reg cgen deff x1 xn e Sfp Ssp swan qu addiu Ssp Ssp 4 cgen e lw Sra 4 Ssp addiu Ssp 55p Iw fp 0 sp a Mex m
function definitions is that both of these will depend intimately on the layout of 

49.5
slide
Code Generat on ll New instruction jr reg Jump to address in register reg e Note The frame pointer points to the Jhove Sfp Ssp top not bottom of the frame 01559 The callee pops the return address the addiu 55p 35p 4 actual arguments and the saved value of the frame pointer cgen E Iw Sra 4 Ssp 1 8 addiu 35p 5p z w sfp 0 sp jr Sra Mex Am
the activation record. So really, co-generation for function calls, co-generation for function definitions and the layout of the activation record all 

56.78
slide
Before call FP SP Code Generation On entry Before exit After call FP old fp old fp SP v y X X EB return Mex mm
need to be designed together. Now for this particular language, a very simple 

62.11
slide
Code Generation Solution use a frame pointer Always points to the return address on the stack Since it does not move it can be used to find the variables Alex Aiken
activation record will be sufficient. Because we are using a stack machine, we 

66.619
slide
Code Generation ll Solution use a frame pointer Always points to the return address on the stack Since it does not move it can be used to find the variables Let xi be the ith i 1 n formal parameter of the function for which code is being generated cgen xj lw a0 z 2 my mm
are modeling a stack machine in our code generation. The results of a function call will always be in the accumulator and that means there is no need to store the results of the function call in the activation record And furthermore, the activation record will hold the actual parameters. So when we go to computer function call with arguments X1 through XN, we will push those arguments onto the stack And as it happens, these are the only variables in this language that are no local or global variables other than the arguments to a function call And so those are the only variables that will need to be stored in the activation record. Now recall that the stack machine discipline guarantees that the stack pointer is preserved across function calls. So the stack pointer will be exactly the same when we exit from a function call, as it was when we entered the function call And this means we won&#39;t need a control link in our activation record. The point of a control link is to help us find the previous activat ion, and since, the stack pointer is preserved, it will have no trouble finding it when we return from our function call, and we&#39;ll never need to look at another activation during a function call since there are no non-local variables in the language. We will however need the return address and that will need to be stored somewhere in the activation record And, one more thing. It turns out that a pointer to the current activation will be useful. Now this is to the current activation, not to the previous activation And this pointer will live in the register, FP, which stands for Frame Pointer. This is a conventional, this is a, this is the register name on the MIPS and the name is chosen, to denote the frame pointer And by convention, the compilers put the frame pointer there. What the frame pointer is good for, well it points to the current frame, so that&#39;s what the name comes from. But, what it&#39;s good for, we&#39;ll see in a few minutes. Right so to summarize for this language an activation record that has the caller&#39;s frame pointer, The actual parameters and the return address will be sufficient. So let&#39;s consider a call to the function F and has two arguments X and Y. Then at the time the call is performed before we start executing the body of the function this is what the activation record will look like, So we&#39;ll have the old frame pointer. So this is the frame pointer that points to the caller&#39;s frame. Not to the frame of the function that we&#39;re executing And the reason that it does that is that we have to save it somewhere because the frame pointer register will be overwritten with the frame pointer for the current activation so we have to save the old one, so that we can restart the caller when we return to it, from the current function. And then there the arguments of the function and those that are pushed on the stack in reverse order. So the last argument is pushed on first and the first argument is at the top of the stack And the reason for doing it this way is it&#39;ll make the indexing to find the a rguments a little bit easier. A little bit simpler And then We have the stack pointer so there&#39;s a, there&#39;s nothing here. What will go here is the callee, the function that we&#39;re calling, will push on the return address. So this is where the return address will go And these elements, the callers frame pointer, the arguments to the function and the return address of the call function will make up the activation record of F. A bit of terminology, the calling sequence is the sequence of instructions that both the caller and callee to set up a function invocation, okay? So that&#39;s referred to in compiler lingo as the calling sequence And we&#39;re going to need a new instruction to show the calling sequence for this for, for function calls. And that will be the jump and link instruction. So jump and link what it does is it jumps to the label that it&#39;s given as an argument And it saves the address of the next instruction after the jump in link, in the register R.A. Which stands for, return address. So, what would happen in the jump in link instructions, if I have jump in link to label L And then there&#39;s an add instruction that comes next. I don&#39;t know what it is. It&#39;s the address of this instruction, the one after the jump in the link that will be stored in the ret-, in the, in the register RA. So this instruction will jump to L. It will store the address of this add instruction in RAb And it will execute whatever code is at L. And then the code that&#39;s at L can execute a jump back to the address in here to execute the return, to the caller. So now we&#39;re ready to actually generate code for a function call expression. So let&#39;s say we have the call, F of E1 To EN Where of course E1 through EN are expressions. And let me change colors here. So these are expressions, here, not values. So how are we going to do that? &gt;&gt; Well, the first thing we&#39;re going to do is we&#39;re going to start building, the activation record And so we save the current frame pointer. This is the frame pointer for the collar. &gt;&gt; Okay. &gt;&gt; This is pointing to th e collars frame. &gt;&gt; Right &gt;&gt; And we store that at the stack pointer. We have to bump the stack pointer. And then we generate code for the last argument, for EN, right? And so that code gets inserted here And then we push it on the stack. So we store the results of EN which will be in the accumulator A0 on the stack and then we, bump the stack pointer. Alright, and we&#39;ll do that for all the arguments finishing up with E-1. So, we generate code for E-1 and we push it onto the stack. So, now all the arguments are on the stack and now we just do the jump in link. So, we&#39;ve done as much of the work or much of the calling sequence as we can do on the caller&#39;s side. So, this code is executing in the function in the caller. Okay, so this is the caller side of the calling sequence, and it builds up as much of the activation record as it can. In particular it&#39;s evaluating the actual parameters and pushing them on to the stack to form part of the activation record, for the called function, and then we do the jump and link. And we jump to the entry point of the function that we&#39;re calling. So we&#39;re, this is a call to, to F, and so we jump to F&#39;s entry point. So a few more things to note, First of all, as we discussed on the previous slide When we execute the jump in link instruction that is going to save the return address in the register RA And that address will be this address here, the one that comes after the, the address of the next instruction, after the jump in link instruction And you&#39;ll notice also that the activation record we&#39;ve built so far is four times N plus four bytes. So this is where N here is the number of arguments. Each argument takes up four bytes, and then four bytes for the old frame pointer. Now we&#39;re ready to talk about the callee side of the calling sequence And we&#39;re going to need one new instruction for that. The JR instruction stands for jump register. And it just jumps to the address in its register argument. So now, the callee side is the code for the function definition, okay? So this is the co de that actually executes the body of the function. And how do we generate code for that? Well let&#39;s take a look. Now actually the very first thing that should be here is that this first instruction of the call side is the entry point. So, we&#39;re missing the label here So this would be labeled F entry. Okay So this is the target of the jump in link instruction. And then the very first thing we do is we set up the frame pointer. So we copy the current value of the stack pointer into the frame pointer. That sets, that points to the end of the frame for the call-ee, for the new function that&#39;s being executed. We also save the return address at the current position on the stacks. Remember there was one more thing to do one thing one thing that was missing. On the caller side on the caller side of the sequences which is the return address. We don&#39;t know the return address until after the jumping link instructions executes And so the callee is the one that has to save that value. Okay so after the jumping link the RA register contains the return address and that we save it into the frame. All right, and then we push the stack pointer. &#39;Kay. And now we just generate code for the body of the function. So now the, at this point the activation record is completely set up, and now we can just generate code for the function body. And after the function body executes, of course, the stack pointer will be preserved, and, and that means that the return address will be at four offset from the stack pointer, so we can load the return address back into the return address register And then we can pop the stack So here we&#39;re going to pop off The current frame from the stack And that&#39;s going to be song size, z. Which we I haven&#39;t shown you what it is yet But, we&#39;ll calculate The size of z in just a minute? This is going to be an immediate value. So it&#39;s a constant that we plug in there And then we load the old frame pointer. Okay So once we&#39;ve incremented the stacks we popped off the existing frame, and so now we&#39;re pointing at the frame pointer at the first we&#39;re, we&#39;re, we&#39;re pointing at the first thing beyond the previous stack frame, and, what was that, well, that was the first thing that we saved in the stack frame for F, and that&#39;s the old frame pointer. So now we restore the old frame pointer so that the call, the function that called us, we&#39;ll have its frame pointer back, and then now we&#39;re ready to return it resume execution of the calling function. We just do that by a jump register to the return address, All right? So note here that the frame pointer points to the top of the frame, not the bottom of the frame. Okay? So that will actually be important when we talk about how we use the frame pointer When we get to talking about the variable references next And the callee pops the return address, The actual arguments in the saved value of the frame pointer from the stacks. So the callee pops off the entire activation record, and also restores the caller&#39;s frame pointer And what&#39;s the value of Z? Well, there are N arguments. Each of which take up four bytes So there&#39;s at, so the size of the activation record is four times N. Plus, there are two other values. In the activation record One is the return address. And the other one is the old frame pointer. Okay and the space for two more words is eight bytes. So that&#39;s the size of the activation record. So that&#39;s how much we have to add to the stack pointer to pop the activation record for F off the stack. Just to give you a sketch of, what this looks like before the call. We have the frame pointer for the caller, and we have the, The current value of the stack pointer And on entry to the function. Okay, after the calling after the calling functions side of the calling sequence has completed what&#39;s on the stack, well, we have the old frame pointer, and the two arguments, and then the stack pointer points to the next unused, location. Which is where the return address will go Alright, then we do the jump and link. We jump over, and the return address gets pushed on to the stack, a nd the frame pointer gets moved to point two, the current value of the frame. Okay, you&#39;ve got to point to the top of the frame. Okay? And then after the call, what has happened? Well, we&#39;ve popped everything off the stack, we&#39;ve popped the entire. Your activation record for the call function off of the stack And so now notice that we&#39;re back in the same state. So again, function calls have to preserve the invariant that. The stack is preserved across the call so the stack should be exactly the same after the call, as it was on entry to the call. So we are almost done with code generation for simple language. The last construct we need to talk about is how we generate code for variable references. Now the variables of a function again are just its arguments just the parameters to the function. There are no other kinds of variables in this simple language And these variables are all in the activation record. So we really all we have to do is generate code to look up a variable in its appropriate place in the activation record But there is one problem, and that&#39;s that the stack does grow and shrink with intermediate values. So when you call a function and you begin executing its body values will be popped and pushed onto the stack beside the activation record. So think back to the code generation for plus and minus and if then else intermediate values were being pushed and popped from the stack And so what this means is that these variables that are in the activation record are not at a fixed offset From the stack pointer. So we can&#39;t use the stack point very easily to the side or to find those variables. So the solution is to use the frame pointer. The frame pointer always points to the return address in the activation record and because it doesn&#39;t move during the execution of the function body, we can always find the variables at the same place relative to the frame pointer. So, how do we do that? Well, let&#39;s consider the i-th argument, X of I and does the i-th argument to the, to the function. So where is that going to be relative to the frame pointer? That will be at offset Z from the frame pointer And Z is just four times I. Right, and this is actually the reason here for generating for pushing the arguments on the stack in reverse order, starting with the last argument to the function, because it just makes this index calculation simple. It wouldn&#39;t be that much more complicated if we pushed the arguments in the other order. It just makes it a little easier to see how the indexing works And anyway this index, this offset, is being calculated at compile time. So, notice that this number, this four times I, is something that the compiler knows, and what we&#39;re putting in the code here is just a fixed offset. So, we are not actually doing that multiplication at run time. See here is just a number, as computed statically by the compiler. So anyway We just load and off send Z which is the four times I where I is the index, the position of the variable in the list of parameters. At that offset from the frame pointer, that&#39;s where XI is stored in the activation record And we just load it into the accumulator. So that is the entire code generation for a variable reference. Here&#39;s a little example. So for the function, the hypothetical function that we&#39;ve been looking at, with two parameters x and y. X is going to be at the frame pointer +four and y will be at the frame pointer +eight. 

