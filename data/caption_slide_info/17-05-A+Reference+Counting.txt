3.87
slide
Compilers 1 Reference Counting
In this video we&#39;re going to conclude our discussion of automatic memory management with the third and last technique we&#39;re going to talk about for garbage collection 

12.13
slide
Reference Counting Rather that wait for memory to be exhausted try to collect an object when there are no more ointers to it Store in each object the number of pointers to that object this is the reference count Each assignment operation manipulates the reference count
called Reference Counting. So the basic idea behind reference counting is that rather than waiting for memory to be completely exhausted, we&#39;re going to try 

22.36
slide
Reference Counting new returns an object with reference count 1 Let rc x be the reference count of x Assume x y point to objects 0 p Every assignment x y becomes rc p rc p 1 rc o rc o 1 if rc o 0 then free 0 x y
to collect an object as soon as soon as there are no more pointers to it. So as soon as we discard the last pointer to an object and it becomes unreachable, we will try to collect it at that point in time. And how can we do this? Well, as the name suggests we&#39;re going to count the number of references to each object. So in each 

39.44
slide
Reference Counting Advantages easy to implement a collects garbage incrementally without large pauses in the execution Disadvantages cannot collect circular structures manipulating reference counts at each assignment is very slow Alex Aim
object we are going to store the number of pointers to that object. So if I have an object in memory, and it has say, three pointers to it from other objects then 

51.269
writing

somewhere in this object is going to be a dedicated field that contains the number three. And if this number ever drops to zero, if we discard these pointers and this number becomes a zero, then we know that nobody is pointing to this object, and it can be free. And what this means is that every assignment has to manipulate the reference count in order to maintain an accurate count of the number of pointers pointing to an object. So allocating a new object, returns an object with a reference count of one. So when a object is created by new it will already have a reference count of one. The pointer that is returned is the only reference to the object. And so we&#39;re gonna write the reference count of an object x is rc of x. And now when we have an assignment x gets assigned y we&#39;re going to have to update the reference counts of both the object that x points to and the object that y points to before the assignment. So, what happens here? So, if y points to p, so let&#39;s draw our objects here, so y is a local variable and it points to some object p in memory, and x is also a local variable and it points to some object, o. Okay? So now x is getting the value of y and so that&#39;s going to move this po inter from where pointer before, pointing to the same thing as y. So what&#39;s going to happen, while p&#39;s reference count is going to go up by one, and o&#39;s reference count is going to go down by one. And since we decremented o&#39;s reference counts, as we dropped this pointer to the object o, we need to do a check to see if the reference count has become zero. And if the reference count has dropped to zero, then we can free the memory for o. And then in addition to updating the reference counts and checking whether the reference count of o became zero, we actually need to do the assignment itself, alright? So every assignment, I want to stress that, every single assignment in the program it&#39;s now translated into these four operations that need to be done to maintain the reference counts. There are tradeoffs in reference counting. It has advantages and disadvantages. One of the big advantages is that it collects garbage incrementally without large pauses in the execution. So for, for kind, for applications where large pauses would be problematic, say real time applications or interactive applications, reference counting can really help because it minimizes the length of the longest possible pause. Okay, so your program will never go to sleep. And just appear to stop running for some period of time because it&#39;s off collecting garbage. It always collects the garbage in small incremental amounts, and so that you never see a long pause. Reference counting, or at least a basic implementation of reference counting is also quite easy to implement. It&#39;s very straight forward to go through and modify the code to add reference counts. So you can easily imagine a code generator that would simply generate different code for, for the assignment operation than it normally did if you were adding reference counting to an implementation. So really the, the changes that are needed for a simple implementation of reference counting to a compiler are not that pervasive. Now there are some disadvantages , to reference counting. One, is that manipulating the reference counts at each assignment is really quite slow. So, if you remember what happens, we have a couple of updates to reference counts, so we have to update, you know, the reference count of two objects. To do an assignment. This is, this is the code to do an assignment and then we have an if statement. And then we actually, do the assignment itself. So there&#39;s two reference count updates that&#39;s has to see if our reference count became zero and then we actually do the assignment. So the overhead here is substantial. You&#39;re taking every single assignment, in the program and blowing up its cost by at least four or five times. And that will have a very noticeable impact on the performance of many programs. Now it is possible to optimize reference counting. So for example, if we had two updates to the same object, say within a basic block or even within a control flow graph, a compiler, a smart optimizing compiler, could frequently combine those reference count operations together. So instead of updating the reference count to the object two times, it can just update it one time. And, similarly if there were even more reference count updates, potentially all of those could be coalesced within some region of the program. The problem with that, is that is becomes very tricky to get that right. So a, a simple implementation of reference counting is quite slow. But easy to get right. A very sophisticated implementation of reference counting or highly optimized implementation of reference counting, is somewhat faster. Still has a noticeable performance impact if you&#39;re reference counting all objects but it is substantially faster. However, it&#39;s quite tricky to get it correct. The other problem with reference counting is that it cannot directly collect circular structures. So to see this let&#39;s draw, a little heap with a circular structure. And so let&#39;s say we have a local variable x and it points to some object in t he heap. And that object has a pointer to another object, alright? And that object, that second object then has a pointer back to the first object. Okay so here x is pointing to say a circularly length list of length two, alright? And if we add in the reference counts here, what would those look like? Well, this object down here the second object here actually one reference to it so its reference count will be one. And this first object has two pointers to it, one from x and one from the other object and so its reference count is two. Okay, so here is our little heap and we can see that there is no garbage here because all the objects are reachable from a, a local variable or variable of the program. Now if we were to assign a new value to x, lets say that we have the assignment x gets null. Alright, so this pointer goes away. But what&#39;s going to happen? Well when we do that assignment, we&#39;re going to change the reference count here of this object, it&#39;s now gonna be one. And if we look at this heap we now see that these objects, these two objects are unreachable. Okay, so these are unreachable. But notice that the reference counts are not zero, so we can&#39;t collect them. The garbage collector or the reference counting implementation, will check the reference counts and see oh, these are one and so we can&#39;t delete them. And then, what it can&#39;t see is that the only references to these objects are from other, unreachable objects. So, the bottom line is that reference counting can&#39;t collect circular structures and there is only really two ways to deal with that. One is if the programmer remembers whenever a circular structure is going to become unreadable, to somehow break the circularity. So for example, before we clobbered the pointer to x here, we remembered to go in and say set, you know, this pointer here to null. If we nulled out one of the pointers in this cycle, so that there was no longer a cycle, then the reference counting would work correctly because then the reference count of this object would go to zero when, when this pointer was dropped from x and that would cause the reference count of this object also to go to zero after this object was deleted, okay? The other possibility is to back reference counting by some other garbage collection technique that can collect cycles. And so, in some reference counting systems for example most of the garbage collection is done by reference counting but every now and again, once in a very, very while, you might want to mark and sweep collector to go through and clean out any circular but unreachable data structures. 

