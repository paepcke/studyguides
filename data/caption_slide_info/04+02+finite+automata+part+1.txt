4.24
slide
Compilers 1 Finite Automata
Welcome back. In this video we&#39;re going to talk about finite automata which we&#39;ll see in future videos are a good implementation model for regular expressions. So in the last few videos, we&#39;ve been talking about regular expressions which we use as the specification language for lexical 

23.4
slide
Finite Automata Regular expressions specification Finite automata implementation A finite automaton consists of An input alphabet Z A set of states 5 A start state n A set of accepting states F g S A set of transitions state state
analysis. And, in this video we&#39;re gonna start something new. We&#39;re gonna talking 

27.939
writing

about Finite Automata which are the For a convenience as an implementation mechanism for regular expressions. And so regular expressions and finite automaton are very close related. It turns out that they can specify exactly the same languages called the regular languages. We won&#39;t prove that in this course but we&#39;ll certainly make use of that fact. So, moving right along, What is a finite automaton? Well, here is a typical definition as you might see in a automaton theory textbook. Finite automaton consists of an input alphabet. So, it&#39;s a set of characters that it can read. It has this finite set of states. We should probably emphasize that. This is what makes it a finite automaton is that it has some set of states that it can be in. One of those states is special and it&#39;s designated as the start state. Some subset of the states are accepting states so these are the states that. But, well, we&#39;ll just find that more in a minute but intuitively, if the automaton terminates, after reading some input on one of these takes that it accepts the input. Otherwise, it rejects the input and finally the automaton has some set of state transitions that is in one state, they can read some input and go to another state. So let&#39;s look at that little more detail so a transition in a finite 

109.729
slide
Finite Automata Transition 51 a3 s2
automaton. If I&#39;m in, in this case I&#39;ve written out one particular transition 

114.069
writing

here. We&#39;re in state one and we read the input A then, the automaton can move to state two, okay. And there could be lots of different transitions for the automaton from different states and different inputs and its read the following way. If we&#39;re in state one on input A , we would go to state two. And, if the automaton ends in an accepting state when it gets to the end of the input that is going to do what&#39;s called accepting the string Meaning that it will say yes, That string was in the language of this machine. So intuitively the automaton starts in the start date and it repeatedly reads inputs one input character at a time makes a transition. So it&#39;ll see what kind of transition it can make out of its current state based on that input to another state and if that&#39;s done ringing the input it&#39;s in one of the final states that it will accept. Otherwise is going to reject the input. Now, one of the situations in which it rejects, well, if it terminates In a state S, that&#39;s no one of the final or accepting states, okay? So that ends in any other state besides one of the accepting states and it&#39;s going to reject. If the machine gets stuck, Meaning it finds itself in a state and there&#39;s no transition of that state on the input. So in particular, let&#39;s say that in some state as a news and the input is A, and there&#39;s no transition. There&#39;s no transition specified per state as an input A so the machine can&#39;t move anywhere and it get stuck and that&#39;s also a rejecting state. And so in these two situations, if, if you either get to the end of the input and it&#39;s not in a final state or. If it never reaches the end of the input because it can stuck and both of those cases it rejects the string. That string is not in the language of the finite automaton. Now there&#39;s an alternative notation for Finite Automata that I think is more intuitive for examples and so we&#39;re going to emphasize that way of writing the mount. In this notation a state is represented as a known graph which just draws a big circle. The start state is represented as a node that has an edge or an arrow into it with no source. So, this is a transition into the node but no source node that it comes from and that indicates the unique start state. An accepting state is drawn as a node wit h just double circles like this. And finally a transition is drawn as an edge between two nodes of the graph. So with this as the time in this state that I&#39;m circling in blue and I read the input a well then I can move to this state at, at the tail of the arrow. So now, let&#39;s do a simple example. Let&#39;s try to write up the 

293.229
slide
Finite Automata A finite automaton that accepts only ex mm
automaton that accepts only the single digit one. So all we need is start state. 

301.08
writing

And will probably want an accepting state as well and now the questions is what do we put in between the two? Well, there would be some kind of transition here and it&#39;s a good guess that we should take that transition if the machine reads the one. Now let me take a moment here to talk about how the machine executes so let&#39;s label these states. Let&#39;s call this state a and let&#39;s call this state b, okay. So the machine will have some input. Okay, and we can write that input out will be here. So let&#39;s just say, we have the single character one and it begins in some state namely the start state. And so, one configuration of the machine is the state that it is in And the input. And typically we would indicate where it is in the input by just a pointers saying what position it is in the input. And, the important thing to know about input in [inaudible] the input pointer always advances. So, when we, or it only advances so when we read a character input, the input pointer moves to the right and it never moves back. Alright, So from state a, we have a rule. We can see that we&#39;re in state a. The next input character is a one and that allows us to take a transition to state b and so now where b in state b and where as our input point well it&#39;s beyond the end of the input indicating we are at the end of the input. And so now this is. We are in an accepting state and we pass the end of the input and so we accept. Okay? So let&#39;s, do another execution. So we start in state a and let&#39;s take as our input the string zero. Okay. And I&#39;d like to draw the pointer. Actually I should have drawn it before the input so we&#39;ll al ways put the pointer between two input elements. In this case it&#39;s a merely to the left of the one we&#39;re about to read. So in this case we&#39;re about read zero so in state a. Our input is zero. We look at our machine. We see that there is no transition on zero. All right? And so the machine stays stuck. It doesn&#39;t make any move at all and this is our final configuration. And we could see that we&#39;re not at the end of the input and so this is a reject. Okay, so in this case the machine rejects that string as not being in the language of the machine. Let&#39;s do one more example. Let&#39;s say that we&#39;re in state, well we&#39;re always beginning in state a and the start state, and let&#39;s say our input this time is the string ten, okay? And our input pointer is there. All right? So again we&#39;re in state a. The input is a one and so we&#39;ll move to state b. And now the input doesn&#39;t change. Just the input point changes but I&#39;ll just copy the input over to show the difference. Now the input pointer has advanced cuz we&#39;ve read one character of input and now we&#39;re in another state. And now we can see that we&#39;re in state b. Our next input is zero and there is no transition on zero from state b and so even though we&#39;re in an accepting state, b as a final state, it&#39;s one of the accept state and we haven&#39;t consumed the entire input. And so this, The machine also rejects this string so this is also a reject. And in general we can talk about the language. Of a finite automata that is equal to the set of...accepted strings. Okay? So the language of a finite automaton, when I&#39;m talking about the language of a finite automaton, I mean the set of strings that the automaton accepts. So now let&#39;s do a more complex example. 

546.959
slide
Finite Automata A finite automaton accepting any number of followed by a single 0 Alphabet 0 1
Let&#39;s try to write out an automaton that accepts any number of one followed by a 

551.779
writing

single zero. So once again well need a start state and we&#39;ll also need a final state and now let&#39;s start by thinking about what&#39;s the shortest string is that&#39;s in the language of this machine. So in this case, we know it has to end in a singl e zero. So a zero definitely has to be, a zero transition has to be the last move and before that zero can come any number of what? In a particular there could be no 1&#39;s. So one transition in this machine is that from start state on input zero we can definitely go to the final state because the single string consisting of a single zero isn&#39;t the language of this machine. And now the only question is how do we encode the fact that any number of 1&#39;s can proceed to zero? Well, there is an easy way to do that. We can just add a [inaudible] by the start state. And take that transition if we read at one. And what does this mean? This means that we&#39;ll stay in the state, state as longer are we&#39;re reading 1&#39;s and as soon as we read zero, we&#39;ll move to the final state because that has to be the end of the string if the machine is going to accept it. So let&#39;s do a couple of examples to convince ourselves that this works. Let me label this state?s again. So this is state a, and that&#39;s stat b. So Let&#39;s write out here states and input. So we&#39;ll begin in state a and let&#39;s take as input 110, okay. So let&#39;s do an accepting case first. All right, So our input pointer begins to the left of the first character. So, we&#39;re in state a in start state. We&#39;re reading a one and that says we should take a transition that puts us back in state a. And so, we advance the input pointer. And now we consume the first one and, and again we&#39;re in state a and the next input is a one so we&#39;ll make another transition to state a. And the input cleaner will advance. So now we&#39;re in state a and the next input is a zero and so we&#39;ll take the transition to b and now in this configuration, so the input pointer has reached the end of the input we&#39;re in an accepting state and so the machine accepts. 110 is in the language of this machine. So now let&#39;s do an example where we will reject the input. And what configuration do we begin in and again a configuration for a finite automaton that just means you know a point in the execution it alwa ys consist of a state and a position of the, the input pointer. So our initial state is a and now let&#39;s just choose the string. I don&#39;t know, let&#39;s take 100 and let&#39;s confirm that this is not in the language of the machine. All right, So we begin in state a and our input pointer is there. Now we read a one and that means, well, you know. So it&#39;s from state a transition of one. We stay in state a and the input pointer advances. And now we see a zero. So from state a and input zero, we make a transition to state b. And now the input point is here so now, we&#39;re in state b and we have an input of zero but there is no transition the b and zero, there are no transitions out of b at all and so the machine gets stuck, it can&#39;t get to the en of the input and again, even though we&#39;re in an accepting state we haven&#39;t read the entire input yet and so that means the machine will reject. And so, 100 is not in the language of this machine. 

