4.01
slide
Compilers 1 Cool Semantics AAAAAA an
In this video we&#39;re going to continue and complete our discussion of cool operational semantics. We&#39;ll be taking a look with the two most complex operations 

11.6
slide
l Cool Semantics Informal semantics of new T Allocate locations to hold all attributes of an object of class T Essentially allocate a new object Set attributes with their default values Evaluate the initializers and set the resulting attribute values Alex m
in cool, the allocation of the new object and dynamic dispatch. We&#39;ll begin by 

20.119
slide
Cool Semantics For a class A we write c a ss A a1 T1 e e1 an Tn e en where ai are the attributes irEluding the inherited ones Ti are the declared types e are the initializers Mex mm
giving an informal discussion of what happens when a new object is allocated in Kuhl. So, the first thing that has to happen, if we have to allocate space for 

28.529
slide
Cool Semantics T0 if T SELF TYPE and so X then X else T class To a1 T1 e e1 an Tn e en i newloc S fori 1 n V To a1 l1 wan In 1 stDTl I1 DTn In a1 1 an In v S1 F alee1 aneen vmsz so E SknewT v S2 ex um
the object and essentially, that means having enough space for the object attributes. We&#39;re going to have to allocate a location for every attribute of the object of class t if what we&#39;re doing is allocating a new t object. Then we&#39;re going to set the attributes of, of that object to their default values and well in 

49.229
slide
Cool Semantics The first three steps allocate the The remaining steps initialize it By evaluating a sequence of assignments State in which the initializers are evaluated Self is the current object Only the attributes are in scope same as in typing Initial values of attributes are the defaults Alex mm
a few minutes, we&#39;ll see what the default values are and why we need to set the, set the attributes to defaults. And then we evaluate the initializers so every attribute in the class declaration can have an initializing expression. We&#39;re 

63.519
slide
Cool Semantics Informal semantics of e0 f e1 en Evaluate the arguments in order e1 en Evaluate eO to the target object Mex mm
going to evaluate those and set the resulting attribute values And then we 

68.48
slide
Cool Semantics ll For a class A and a method fofA possibly inherited imp A f x1 xn ebody where xi are the names of the formal arguments ebodv is the body of the method Mex mm
return the newly allocated objects. So these are the steps that are involved in setting a new object and as you can see it&#39;s actually more than just allocating a 

77.61
slide
Cool Semantics so E v1 so E v2 S2 50 E 5 1 1 e v Eu 50 E 5n eO V01 sn 1 V0 1I I am Im XI I an ebody xi newloc Sn 1 fori l n E 31 llr Iam Im X1 lxll 1 Xn lxn Sn 2 Sn 1 V1 xll IVn Ixn Vo l E r Sn 2 ebodv 1 V Sn 3 so E S F eo f e1 en v Sn 3 Alex um
little bit of memory. It&#39;s actually quite a bit of computation going on in allocating new objects in cool. Every class has a default value associated with that class. So for integers, the default value is zero. For Boolean, the default value is a Boolean false and for strings, the default value is the empty string And then for any other class, that isn&#39;t one of these three basic classes or any other class, the default value is void. In the operational rules, we&#39;re going to need a way to repair to the attributes of a class. So we&#39;re going to define a function called class that takes a class name and returns the list of attributes of, of that class. So here we have all the attributes of class a, let&#39;s say that a1 through and in addition, this functions also going to tell us for each attribute declared type of the attribute and the expression that initiali zes the attribute. And one other important feature of this list, is that it includes all the attributes of class a including the inherited ones. And there&#39;s another detail which is in what order these attributes appear and these are actually become important when we define the semantics of how attributes are initialized and the rule is the attributes are listed in greatest ancestor first order And what do I mean by that? Let&#39;s say that we have three classes a, b, and c and a, I&#39;m sorry, b inherits from a. And c inherits. From b. Okay, let&#39;s say, that a defines two attributes, a1 and a2 and b defines two attributes b1, b2 and c defines two attributes c1 and c2. Then class of c. We&#39;ll list the attributes in the following order. First we&#39;ll come a1 and then a2 Because a is the greatest ancestor, okay, it&#39;s the, the closest to the root of the object hierarchy and the attribute was in class a or within any class, it&#39;s always listed in the order that it textually appear. So, first comes a1 and a2 and of course the type in the initializer are also, let&#39;s see here, most of these attributes but we&#39;re just concentrating here in the order in which the information appears. So, the next would come class b. So, the attributes of class b will be next and of course, there&#39;ll be the type and initialize for those attributes and then finally the attributes of class c Again, in the order in which they are listed in the class definition, okay? So, that defines the order of the attributes for any class. It&#39;s always in the order of the greatest ancestor down the inheritance chain to the class itself which is the argument of the class functions. At this point we&#39;re ready to actually define the formal semantics of new t and let switch colors here. So we&#39;re going to be allocating a new object of type and is going to be in a context with self object as zero environment e and store s. The first thing we have to do we&#39;re going to figure out what kind of object it is that we&#39;re actually going to allocate and the only question is whether t is se lf type or not because remember self type is not the name of an actual class. If t is not self type then the class that we&#39;re going to allocate is actually a t. T is actually a class name and with that, that&#39;s the kind of object that we&#39;re going to allocate. If t is self type then the kind of object we&#39;re going to be allocating. Is whatever the class is of the self objects? So we&#39;re going to look at the dynamic type here of the self object called that x and that will be the class that we create. That will be the kind of objects that we created, all right? So there&#39;s two possibilities, Either object, object, allocating an object of type t if t is actually a class name. Otherwise it&#39;s an object of the same dynamic type as the self object Alright? So, now we&#39;re going to look up t0 is, alright. And we get out the list of the attribute types and initializers for t0. So, this tells that what we have to do to construct an object of this type. Alright and the next thing we do is we allocate locations for each of the attributes. So, because they were in attributes, we&#39;re going to allocate n locations. One for each attribute, all right. And then we&#39;re going to create an object with the class tag t0 and the attributes are going to be bound to these new locations. So, the i attribute will be abound to the i new location that we just allocated and that were going to update the store. Okay. So, we&#39;re going to take our initial store and know this is the same with the store we started with. We take s and we are going to update it so that at these new locations, those new locations hold the default values of, for the type of each of the attribute. Okay, and that gives us the store s1 and now we have to evaluate the initializer. The two actually, initialize the attributes. And we have to think about what the environment is in which those attributes are initialized and remember the rule is that within initializer I mean, attribute, all the attributes of the class are in scope. Alright, so the environment in this case for the initializers will ju st consist of the initializer or the attributes, excuse me, themselves. Okay, so these are the attribute names and the i attributes is bound to the i&#39;s new memory location holding the value, the default value initially of that attribute. Alright, and then finally, to evaluate initializers, we just evaluate them as a block in the order which they appear in the class function. This is why it was important to specify the order in the class function. So remember that these attributes include all the inherited attribute so we&#39;ll start by evaluating initializing attributes with the greatest ancestor and working our way down to the attributes declared within the class itself. Notice that the environment here. Which has all of the attributes in scope is an interesting point, this environment has nothing to do with the environment in which new t is actually evaluation. You know, these environments e and e prime are completely separate, okay? So new, so e prime has in scope the names of the attributes the class e is a, you know, is, is some other environment. There&#39;s some functions somewhere that&#39;s calling new t and the variables are in scope there are just completely different, okay? But anyway, evaluating this block Of initializers will yield some value. And the new store the value isn&#39;t used for anything, okay? But the new store is the final store. That&#39;s the store that we get out as a result of allocating the object and then what is the result of new t, well it is the new object itself, v. To summarize the semantics of New that was the first three steps allocate the object, actually allocate the memory for the object and then the remaining steps initialize the objects by evaluating a sequence of assignments and the most important thing probably to understand about initialization and one of the most important things is the context in which or the stage in which the initializers are evaluated. So know that only the attribute are in scope while we emphasize that and it&#39;s the same rule as of typing. So when you &#39;re type checking a class declaration only the attributes are in scope of the you know, for the initializers of the class and then as the same, naturally the same thing that we use when we actually evaluate the initializers at runtime. And the initial values of the attributes are the default values and then, then we need the defaults because, precisely because the attributes are in-sculpt inside their own initializers. So, it could be for example, it&#39;s perfectly reasonable like Kuhls to have an initializer, let&#39;s say, like this. And I&#39;m just going to, I may leave all the types here just to save time but I can assign and attribute a the value of a and this is perfectly okay because the right hand side of the intializer has all the attributes and scope and for this to make sense a has to have some kind of default value. It has to have some initial value so because I might read it, before I might read an attribute before I have actually finished computing its initializer All right? And the last point here, is that notice that in the initialization or in the yeah, in the initialization of an object self is the object itself is the self object. And what do I mean by that? I forgot to mention this on the previous slide just flipping back to that slide for a moment, notice here. That in the evaluation of the initializers, what is the context the self object is v, the self object is v, this is the new object that we have just constructed. And so, it&#39;s perfectly fine for e1 or en, the initialization expressions over here and refers to stealth and what they were referred to if they use self is the object that is being initialized. Alright Returning to this, to our summary you know it might be a little bit of a surprise how complicated the. Semantics of new is, in cool and it&#39;s not just cool that has that property. In fact every object oriented language, language has a fairly complex semantics for the initialization of new objects and it&#39;s a combination of features like inheritance and the ability of initializers to refer to the attributes that leads to this kind of complexity. Now let&#39;s talk about the semantics of dynamic dispatch and we&#39;ll follow the same plan that we did the semantics of new for us giving for us have an informal discussion and high level description of how the evaluation of dynamic dispatch works and then we&#39;ll look at the formal operational rule. So the first thing it happens in evaluating a dispatch is that we&#39;ll evaluate the arguments e1 through en and next we&#39;ll evaluate the target object e0 so that expression to get the actual object to which we&#39;re dispatching. Next, we&#39;re going to look at the dynamic type of the target object. So, after we evaluate the zero, we&#39;re going to look at its class peg is And then, we&#39;re going to use that type to figure out which function which function f we&#39;re supposed to use. So, we&#39;re going to go and look in the method table for the class x and see what method it has for f. Then we&#39;re going to create new locations and an environment for the call. Alright, and we&#39;re going to set up a new locations for the actual parameters. We&#39;re going to initialize the, those locations with the actual arguments. Where s itself to be the target object and then we&#39;re going to evaluate the body of f. Now in order to do the look up of a method in a class, we&#39;re going to need some representation of what methods exist and which class is in our operational rules. So we&#39;re going to find a function eval stands for implementation and the implementation in a class a of a method f is, is going to be first of all, the list of formal parameters. So it&#39;s going to tell us what the formal parameters are of f and then the body of f Whatever the, the function body of f is. Now we&#39;re ready to actually discuss the details of the formal operational semantics of method dispatch in Kuhl. I&#39;m going to switch colors here again just for contrast. So as we said, the first thing we do is we evaluate the n arguments. So this first in lines, take care of that ad notice that each arguments that&#39;s evaluated may have side effects. So, it starts in some store but it may produce a different store. So after we&#39;ve done all of this we&#39;ll have the n arguments evaluated and some store s (N). The next thing that happens is we evaluate zero. This is the expression to which we are dispatching and that would give us an object v0 and some updated store s (n) + one. Okay And now we have to inspect v0. We want to know what&#39;s inside of v0, what v0 is made of and in particular we&#39;re interested in the classed tag of v0 and we&#39;ll also be interested in the contents of its attributes. The locations associated with its attributes but first let&#39;s focus on the class tag. Alright, because we&#39;re going to use that class, remember, this is the dynamic type of the zeros and what kind of objects the zeros actually is when the program is running. And we&#39;re going to use that class to look up the definition of f that we should run. So, we look for the method f in class x. We want to know its implementation and in particular we get the names of the former parameters. Okay x1 through xn and we get the body of the function or method. Alright So, the next thing we have to do is we have to allocate space in the memory or in the store for the actual parameters of the method call. So, we allocate new locations. Okay, one for each actual argument and that we&#39;re ready to build an environment in which we can evaluate the method, alright? So, what is this environment going to consist of? So, we have to think about what names or in-scoped inside of a method. Well, all the attributes of the class are in-scope. Okay. So, this is a class x with attributes a1 through an so the environment will have those names to find a1 through an. And now what are the attributes or locations of those attributes. Well those are the locations of. The zero, that&#39;s the object that we&#39;re dispatching to that were going to be the self object and the attribute names will refer to the attributes of, of self, alright. So, those locations here are the locations of, of the attributes in the object v0. Now in addition the formal paramete rs are also in scope inside of the method body. So we add to this environment with just the attributes all of the formal parameters okay and they are at the new locations l(x1) up to l(xn). Okay? And notice one slight subtlety about the way this is defined we&#39;re taking an initial environment which I&#39;ll show here with, I&#39;ll, I&#39;ll color these braces in blue. So we&#39;re defining and initial environment of the attributes and then we&#39;re doing updates to that, okay? So we&#39;re, instead of just defining x1 to map two l sub x1, we&#39;re saying we&#39;re replacing The definition of x1 in this environment in the blue braces with one and maps x1 and l(x1). Why do we do it that way? Well, the thing is that a method may have a formal parameter that is the same as an attribute name so for example I could have a class a that has an attribute little a in it And it also has a method f that takes a formal parameter named a. Okay And if I do that, and of course, I&#39;m leaving out types and lots of other things here. So, here I have an attribute named a that&#39;s declared. And then I have a method that takes the argument called a. And then the question is when I refer to a. Inside of the body of the method what a do I get? Is this a, is this a bind to the formal parameters, is it bind to the attribute? And the answer, we have to get one answer or the other, the answer in Kuhl, is that it binds to the formal parameter that hides the, the outer name. Okay, and that&#39;s, and that&#39;s enforced here in the rule by these updates. So, if a formal parameter has the same name as one of the attributes, it will replace the definition of the attribute in the environment. Okay. Once we get the environment set up, we need to set up our store what, what are the changes to the store? What we just have to store the actual value of each argument at the location for that argument. And finally, we are ready to evaluate the functioning body and the interesting part here is the context in which that&#39;s done. So, notice here that the that the self object in, in the context of running the method f is the object to which are dispatching. Okay? And then the environment is e prime, the new environment we just set up and once again notice that this is a complete change of context that e prime, the environment e prime has nothing to do with the environment e. E prime is built completely from scratch using only information about the method for calling, it doesn&#39;t borrow anything from the, from the environment where the method originated, where the method was called from. And finally all of this is done in the store that has, reflects all the side effects performed by evaluating the arguments, by evaluating e0 and by extending the store with the locations for the actual parameters. So to evaluate the body of the method we get back a value and another updated store and that value in store are the results of the entire execution of the dynamic dispatch. 

