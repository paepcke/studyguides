3.419
slide
Compilers 1 Stop and Copy
In this video, we are going to look at the second garbage collection technique, stop and copy. In stop-and-copy garbage collection memory is organized into two 

14.54
slide
Stop and Copy Memory is organized into two areas Id sEace used for allocation new space used as a reserve for GC heap pointer old space new space The heap pointer points to the next free word in the old space Allocation just advances the heap pointer Alex Aiken
areas. We have an old space that&#39;s used for allocation and so all of the data that 

19.359
writing

the program is currently using lives in this area called the old space. And then there&#39;s a new space which is reserved for the garbage collector. And so, this is not used by the program, it&#39;s just for the GC. And so the first decision in stop-and-copy garbage collection is that the program can only use half the space. And there are some techniques more advance techniques, for stop-and-copy garbage collection that allow the program to use more than half the space. So, this isn&#39;t as bad as it 

47.729
slide
Starts when the old space is full Copies all reachable objects from old space into new space garbage is left behind after the copy phase the new space uses less space than the old one before the collection After the copy the roles of the old and new spaces are reversed and the program resumes Stop and Copy
sounds but fundamentally, a fairly significant fraction of the space has to be reserved for the garbage collector. Now the way allocation works is that there&#39;s a heat pointer here in the old space and everything to the left of the heat pointer is currently in use. This is where all the objects have already been allocated in this area that I just shaded here in red. And then when it comes time to allocate a 

72.28
slide
Stop and Copy Before collection AA roof A B C D E F new space Max Am
new object, we simply allocate it at the heap pointers. So, the heap pointer will simply bump up and some block of space will be allocated to a, the next object 

82.82
slide
W Before collection 54A I M CD B C D E F new space hen oinTer After collection roof Pf l A New space A C Llf free A Am
that we want to do. And it will just keep marching through the old space allocating as you allocate more objects. Okay, so allocation just advances the heap pointer so one of the advantages, actually, of stop-and-copy is a very simple and fast allocation strategy. Now eventually, of course, if we allocate over and over again, we&#39;re going to fill up the old space and so garbage collection will start 

106.06
slide
Stop and Copy We need to find all the reachable objects as for mark and sweep As we find a reachable object we copy it into the new space And we have to fix ALL pointers pointingto it As we copy an object we store in the old copy a forwarding pointer to the new copy when we later reach an object with a forwarding pointer we know it was already copied Alex mm
GC, will start when the old space is full. And what it&#39;s going to do is going to copy 

112.189
writing

all the reachable objects, all the reachable objects from the old space into the new space. And the beauty of this idea is that when you copy the reachable objects, the garbage is left behind. So, you simply pickup all the data that you&#39;re using and move it over to the new space and all the junk that you didn&#39;t need anymore is left behind in the old space. And then, after you copy stuff to the new space first of all since you left the garbage behind, you&#39;re using less space than you did before the collection. So, there&#39;s some space available now in the new space for allocating new objects. And then, you simply swap the roles of the old and new space. So, the old and new spaces are reversed what was old becomes the new, and what was new becomes the old, and then the program resumes. So, let&#39;s take a look at a quick example here just to get a idea of how this works. Let&#39;s say we have our old space over here, this is the old space, and we have one root which is this 

170.019
slide
Stop and Copy We still have the issue of how to implement the traversal without using extra space The following trick solves the problem partition the new space in three contiguous regions start scan allcc copied and scanned copied empty copied objects whose pointer fields have NOT been followed yet copied objects whose pointer fields have been followed Alex Nkan


170.019
writing

object A. And so what we&#39;re going to do, well we&#39;re going to make a copy of all the objects reachable from A. We&#39;re gonna move them over to the new space. And what that&#39;s going to look like, well, here it is, afterward. But let&#39;s trace it out. So, we started A, we follow pointers from A, we can see there&#39;s a pointer to C, okay, so C is going to be reachable and there&#39;s a pointer to F , okay. And then F points back to A, and that&#39;s all the reachable objects so we copy them. And notice when we copy them, we also copy their pointers, and now the pointers have all been changed. So, in the copy of A, it now points to the copy of C, okay. And of course, C will point to the copy of F and there&#39;s a little issue here, this line is not in the right place so it should look like that. And then F points back to the 

219.61
slide
Stop and Copy EIFI new 5 pace Max m
copy of A. So, what we know, when the object and move their pointers and we 

222.819
slide
Stop and Copy Step 1 Copy the objects pointed to by roots and set forwarding pointers aHoc root Mex mm
adjust them so that we&#39;ve really copied the whole graph of objects over to the 

226.92
writing

news space. Now, we&#39;re using less space so there&#39;s some free space here, okay. And now, this will become the old space. This now our old space and this is now the new space which we will use for the next garbage collection. To summarize the discussi on so far, one of the essential problems in stop-and-copy is to make sure that we find all the reachable objects and we saw this same problem with mark-and-sweep garbage collection. Now, the thing that really distinguishes stop-and-copy is that we&#39;re going to copy these objects. So, when we find a reachable object we copy it into the new space. And that means that we have to find and fix all the pointers that point to that object and this is actually not 

270.1
slide
Stop and Copy Step 2 Follow the pointer in the next unscanned object A copy the pointed to objects just C in this case fix the pointer in A set forwarding pointer root Mex mm


270.1
writing

obvious how to do, alright. Cuz when you find an object, of course, you can&#39;t see all the pointers that point into that object. So, how are we going to do that? Well, here is an idea. Well, we copy the object, we&#39;re going to store in the old version of it, it was called, a forwarding pointer to the new copy. So, let&#39;s take a look at what that would how that would, how that looks like. So we have our old space, we have our new space. And let&#39;s say, we discover some reachable object A in the old space. So, what we&#39;re going to do is we&#39;re going to make a copy of it over here in the new space and that&#39;s easy enough to do. But now what we&#39;re going to do is we&#39;re gonna take A and we&#39;re going to reuse its space and we&#39;re gonna store what&#39;s called a forwarding pointer in it. So, we&#39;re going to, yeah, first of all, we&#39;re going to mark somehow that this has been copied. So, this will have some special mark on it which I&#39;ll just, you know, indicate with here with a purple bar something. This is we&#39;re marking someway so that we can tell this object has already been copied. And then at a. At a distinguished location in the object, we&#39;re going to store the forwarding pointer. And you can think of this as like a forwarding address. So, if you know where somebody lives you can go to their house and if they have moved, you can ask for the forwarding address. And that&#39;s 

343.91
slide
Stop and Copy Since scan caught up with alloc we are done Swap the role of the spaces and resume the program alloc
exactly and then you can go off to their new house wherever they&#39;ve wherever they&#39;ve gone to and presumably find them. And so, that&#39;s what&#39;s going to happen 

351.46
slide
Stop and Copy while scan alloc do let 0 be the object at scan pointer for each pointer p contained in 0 do find that p points to if is without a forwarding pointer copy 0 to new space update alloc pointer set lst word of old to point to the new copy change p to point to the new copy of else set p in 0 equal to the forwarding pointer fi end for increment scan pointer to the next object od Alex um
here. If we have a pointer that points into this object later on and maybe much 

357.58
writing

later on in the garbage collection, we may discover this pointer, we may follow this pointer, find out it points in this object, realize that this object has moved because we&#39;ve marked it and the object was moved. And then we can use the forwarding pointer to find out where the new object is and then update this pointer wherever it is to point to the new object. Now, just like with mark-and-sweep, we still have the issue of how to implement the traversal of the object graph without using any extra space. Again, when these garbage collection algorithms, they only get used, they only get run in low memory situations. And you can&#39;t assume that you can build unbounded data structures to use with the garbage collectors. The garbage collector really needs to work in constants base. And now here is the idea that will, that is used in stop-and-copy algorithms to solve the problem. So, we&#39;re going partition in new space and this is just the new space here into three contiguous regions. We&#39;re going to have we&#39;ll start with the one on the far right. We&#39;re going to have the empty region where we&#39;re allocating new objects. And there&#39;s an allocation pointer that points to the beginning of that region. So this is the region that we&#39;re filling up with objects that we&#39;re copying over and this is just empty unused space. Now, immediately to the left of that region are the objects that have already been copied, but not scanned, okay? This is copied and not scanned. And, what does that mean? Well, that means that the object has been copied over. And so, we&#39;ve actually, you know, made a copy of the object into the new space. But we haven&#39;t yet looked at its pointers. We haven&#39;t yet looked at the pointers inside the object to see where they go. And then, to the left of that, are the objects that have been copied and scanned. These are objects that have been copied over. And we&#39;ve also processed all the pointers inside of those obje cts. And so, you can think of this area here, between the scanned pointer and the allegation pointer, this is the work quest. So, these are the objects that still need to be processed. These are the objects that have been copied over but might yet still point to objects that haven&#39;t been copied. And so, these are the objects where we have to look at their pointers to see whether they point to something that still needs to be copied over to finish the garbage collection. Returning to our little example, I&#39;m now going to walk through how a stop-and-copy garbage collector would collect this particular heap step by step. So, notice that we only have one root object and it&#39;s A, okay, I just want to point out that A has one pointer which points to object C, alright. So, at the very first step, what we&#39;re going to do is we&#39;re going to copy the A object over to the new space, okay. And this is literally a byte for byte copy. So, we just take the bytes of A and we do a copy without, you know, doing any inspection of the interior of the object, over to the new space. And how&#39;s that work? Of course, our allocation pointer isn&#39;t in, initially right here at the beginning of the new space. And then we add and we copy this one object over. And then that means allocating an object and so now, the allocation pointer points to the first word of memory, beyond the object that we just allocated, okay. Now what happens when we copy it over? Well, because it is just a byte for byte copy, all the pointers in A still point to the objects as they pointed to before which are the objects in old space. And notice now that this copy of A points to the object C in the old space. The other thing we do is we leave a forwarding pointer in the old copy of A. So, we mark A as having been copied, that&#39;s why it&#39;s grayed out. Indicates that this object has already been moved. And that this dotted line here indicates that somewhere, we stored a pointer to the new copy of A. And now, we&#39;re ready to begin the algorithms. And not ice that we have some objects here that have been copied but not scanned so this is our work list. So, now it&#39;s going to repeatedly work off of those objects and how do we know they&#39;re objects in there? Well, we just compare the scan and the allocation pointers. So, if they&#39;re if they are different, if there&#39;s an object in between the scan and the allocation pointer, at least one object between the two, then there&#39;s work to do. There&#39;s an object that needs to be scanned that and, and possibly resulting in more objects being moved and allocated. So, what happens next? So, object, we, we process A, so we walk over A and find all the pointers in A. And we copy any objects that it points to that haven&#39;t already been moved. And so, before we said, you know, the A, this, this copy of A pointed to the old copy of C. So, now what we discover the C object, it hasn&#39;t been moved, it&#39;s still in the old space. So, we copy it over and we update the pointer in A to point to the new copy of C. Now, of course and then the scan pointer moves over A. We&#39;ve scanned all the pointers in A, alright. And the allocation pointer also moves because we had to allocate space for C. And of course, C is just a byte for byte copy of what was in the old space. And so it, any pointers that it has that point to objects that haven&#39;t been moved yet, moved yet just point back into the old space. So, in this case the object C points to the object F in the old space. And I probably should indicate here, here&#39;s the original dividing line, you know, this is the old space over here and this is the new space over there, alright. And finally we mark C as having been copied, having been moved to the new space and we left a forwarding pointer to it in case so we can fix any pointers that point to C that we come across in the future. And now we have to continue scanning objects that have been copied but not scanned. And we can see that there is an object between the scan and the allocatio n pointer namely C and so we&#39;ll now process all the pointers in C. Next, we scan C. And, we discover that it points to F. Which hasn&#39;t been moved yet and so we copy F over into the new space and we update the pointer in C. And now C has been copied and scanned, okay. So, the scan pointer moves past C and of course, F again is a byte for byte copy and so all it&#39;s pointers into old space are still pointing to old space, in particular F points to A and the allocation pointer is moved again because we moved F, alright. And now, we have to process F. And this will be the last object that we move. And what happens, well, we discover that F points to A, okay. And A is already marked as having been moved and it has a forwarding pointer. So, instead of copying A again, we simply update the pointer in F that pointed to the old version of A to point to the copy of A, okay. And so, now F is completely scanned. All the pointers in F have been processed. We didn&#39;t allocate any new objects so the allocation pointer didn&#39;t move and now the scan pointer and the allocation pointer are equal. There are no objects in between them and so our work list is empty and this is the garbage collected heap. This is a complete graph, a complete copy of its A, of the graph of reachable objects from the old space. So, now we&#39;re done and we simply swap the role of the new and old space and we resume the program so that when the program starts running again, it will allocate out of this area and it&#39;ll be on the allocation pointer until it fills up what is now the old space, you know, and then this will be the new space that will be used for the next garbage collection. Here&#39;s a pseudo code algorithm outlining how stop-and-copy garbage collection should work. So, while the scan and allocation pointers are different, remember, we keep running until the scan pointer catches up with the allocation pointer and they&#39;re equal. What we&#39;re going to do is we&#39;re going to look at the object that is at the scan pointer. That we&#39;ll call that objec t , and then for every pointer in O, we&#39;re going to do the following. We&#39;re going to find the object O&#39; that, that pointer points to. And then there are two cases. One is that there is no forwarding pointer, alright. And if there&#39;s no forwarding pointer, then we have to copy that object to new space and that will involve allocating a new object and updating the allocation pointer. Then we&#39;re going to set and here it says the first word, they really shouldn&#39;t emphasize the first word. Set a word. So, it&#39;s a distinguished word, that&#39;s what&#39;s important. We have to know which word we&#39;re going to use and will always be the same word. But anyways, we set a word of the old object to point to the new copy. We mark the old object as copied. Mark old object as copied, okay. So, that&#39;s so that we can tell if we ever come to a pointer to it again, we know it&#39;s already been moved and then we change p, the pointer, to point to the new copy of O&#39;, alright. So, if there was, that&#39;s what we do if there is no forwarding pointer. And if there is a forwarding pointer, then we simply update the pointer to point to the same place as the forwarding pointer. And we just repeat this loop over and over again until we&#39;ve scanned all the copied options. 

