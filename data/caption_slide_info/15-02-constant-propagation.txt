4.569
slide
Compilers 1 Constant Propagation
In this video we are going to continue our discussion on global data flow analysis by taking a look at how global constant propagation works in detail. To begin, 

16.82
slide
Constant Propagation To replace a use of x by a constant k we must know On every path to the use of x the last assignment to x is x k
let&#39;s review what the conditions are to do global constant propagation. So to replace a use of a variable x by a constant k, we have to know the following property. That on, that on every path to the use of x, the last assignment to the variable x is, x equals the constant k, okay? And this has to be true again on every path to the use of x. Now, global constant propagation can be performed at any point where this 

43.73
slide
Constant Propagation Global constant propagation can be performed at any point where holds Consider the case of computing for a single variable X at all program points
property holds. What we&#39;re going to look at in this video, is the case of computing 

48.16
writing

the property for a single variable x at all program points. So we&#39;re going to take one, we&#39;re going to focus on one variable x and we&#39;re going to compute whether it&#39;s a constant at every program point. It&#39;s easy to extend the algorithm to compute this property for all variables. One very simple but very efficient way to do that is just to repeat the computation once for each variable in the method body. The way 

75.21
slide
Constant Propagation To make the problem precise we associate one of the following values with X at every program point value interpretation L This statementnever executes c X constant c T X is not a constant Alex mm
we are going to compute the information that we want is to associate one of the following values with the variable x at every point in the program. And, let&#39;s 

85.79
writing

start with the last one here we will assign x this special value here which is pronounced top if x is not a constant. So if we can&#39;t figure out whether x is a constant at a particular point in the program, then we&#39;ll just say x is top at that point. And, this is going to be our safe situation. It&#39;s always okay to say we don&#39;t know what the value of x is and when we say that x has a value top, and we could say, we, we were essentially saying we don&#39;t know whether x is a constant or not at this point in the program, x could have any value. Alright? Now, another possibility is that we will say that x is some constant c, okay? So this is a particular constant and if we say that x is a constant c at a program point, that means, in fact, at that program point, we believe o r we have proven that x is always that constant. Now, there is a third possibility which is not immediately intuitive, perhaps. But, as we will see, plays a very important role in algorithms for, for global constant propagation. And in fact, in all global data flow analysis, and that is bottom, okay? So this value is pronounced bottom and intuitively the idea anyway that is kind of opposite of top, alright? And the interpretation of bottom is going to be that this statement never executes, alright? So, when we don&#39;t know whether a statement is even executed at all we will say that x at that point has a value bottom. Meaning that, as far as we know that point in the program is never reached. It doesn&#39;t matter what the value of x is at that point because that statement never executes. Alright, so we&#39;re going to assign x one of these three kinds of values. Either bottom, some constant, or top. Let&#39;s begin by working through an example by hand and our goal is going to be for every program point to 

207.22
slide
Constant Propagation A 2 X Alex mm
decide whether x could be a constant definitely not a constant, or whether we 

212.229
writing

think that statement might not ever execute, okay? So, execution will begin at the top of this control flip graph. So this the entry point and before executions begins, we don&#39;t anything about the value of x. So, I&#39;m not making any assumptions about what code came before this basic block and so to be safe, I will say that at this point, x has some unknown value. We don&#39;t know what the value of x is, it could be anything. So x = T, is the property that we want entry to the first basic block. Now after the assignment x = three, that was indicated there, where what point we&#39;re talking about. So, after the assignment x = three, we&#39;ll definitely will know that x is the constant three. Alright, now there&#39;s something here that&#39;s worth pointing out which is that our program points, the points that we&#39;re attaching this knowledge to or these, these facts to are in between the statem ents. So, when I say x = three at this program point, what I mean is that after x, after this assignment has executed, x = three, but before this predicate of the conditional has executed, I know that x = three, okay? So, the program points are in between statements and there&#39;s a program point before and after every statement. Alright, so the next thing that happens is this conditional branch. Notice that the branch doesn&#39;t update x, doesn&#39;t even refer to x so after the branch executes we&#39;ll definitely knows that x = three on both branches. Alright, now let&#39;s do the right hand branch. The next thing that happens is the assignment to y that would not affect the value of x. So after the assignment to y, we&#39;ll still know that x = three, alright? Now let&#39;s take a look at the left hand branch so the first thing that happens over here is another assignment to y. Well that won&#39;t affect the value of x. After the assignment of Y we&#39;ll know that x = three. And now comes to the assignment of x, alright. So after this assignment happens at this program point we&#39;re going to know that the value of x is different. We&#39;re going to know that x = four, alright. So, now after this statement we know x = four and after this statement over here we know x = three, alright? Now what do we know then about what happens before this statement, okay? The a = two x and I just want to point out here. I said that there&#39;s a program point before and after every statement And so this program point here, which is before this assignment to a is different from the program points that are after x = four and y = zero. So intuitively, after x = four we know that we&#39;re still on this path over here on the left and so we know that x = four and over here after y = zero, we still know that we&#39;re on this path is x = three. But, when we reach the point before a = two x, we no longer know which path we&#39;re coming from. This is the point of the merge of these two paths that both lead to this statement. And what can we say about the value of x here? Well, there is no constant that we can assign to x because on o ne path x is three and on the other path, x is four. And so what we have to say here is that before this assignment executes, a = x, sorry, x = T. We don&#39;t know what the value of x is. Another way of saying it is we know we, we don&#39;t know that x is a constant, alright. So, after the assignment executes it doesn&#39;t affect the value of x, we will also have that x = T. Now notice that once we have the global constant information, once we know for every program point, what the state of x 

433.26
slide
Constant Propagation Given global constant information it is easy to perform the optimization Simply inspect the x associated with a statement using X If x is constant at that point replace that use of x by the constant Alex mm
is, it&#39;s going to be very easy to perform the optimization. We simply look at the information associated with the statement and then it will tell us whether x is a constant when that statement executes or not. And if x is a constant at that point, then we can replace that use of x by the constant. And crucial question of course is how do we compute these properties. So, we did this example by hand but how in a systematic fashion, an arbitrary control flow graph do we actually compute these properties for x for every program point? Now we&#39;re ready to talk about data flow analysis algorithms and there&#39;s one basic principle that you see in all of these 

473.74
slide
Costant Propagation The analysis of a complicated program can be expressed as a combination of simple rules relating the change in information between adjacent statements
algorithms that&#39;s worth mentioning right away. And that&#39;s that the analysis of a complicated program can be expressed as a combination of very simple rules that relate the change in information between adjacent statements. So we&#39;re just going to focus on local rules and the way we&#39;re going to build our global data flow analysis is actually by a combination of rules that look only at a single statement and its neighbors. The idea behind the rules is going to be the push or transfer 

506.54
slide
Constant Propagation The idea is to push or transfer information from one statement to the next For each statements we compute information about the value of x immediately before and after 5 C x s in value of x before 5 C x s out value of x after 5
information from one statement to the next And so for each statement s, we&#39;re going 

510.86
writing

to compute information about the value of x immediately before and after s. Remember that&#39;s where, those are the program points that we want to attach information to. So in particular we&#39;re going to have a function C. It stands for constant information and C will take three arguments, takes the name of the variable, x. It takes the stat ement that we&#39;re talking about, the particular statement in the program that we&#39;re looking at. And then either in or out and this is what distinguishes the value of x before s executes versus the value of x after s executes. We&#39;re going to be defining a set of transfer functions that push 

548.67
slide
Constant Propagation Define a transfer function that transfers information one statement to another In the following rules let statement 5 have immediate predecessor statements p1 pn
information or transfer information from one statement to another. And in the rules for constant propagation we need to talk about a statement and its predecessors. So we&#39;re going to say that every statement s has some set of immediate predecessors p1 through pn, alright? So, it&#39;s either of these statements that lead in one step to the statement s. Let&#39;s do our first rule. So we have a statement s and it has some 

574.36
slide
Constant Propagation if C pi x out T for any i then C s x in T Rule 1
set of predecessor statements, P1, P2, P3, P4. And the situation that we&#39;re 

581.65
writing

interested in here is, let&#39;s assume that x is top at the program point after one of these predecessors. So, after some predecessor, it doesn&#39;t matter which one, if it happens that x is top at the program point after that predecessor, well, then x has to be top before the execution of s, okay? So that&#39;s what this rule says. It says if the out of any predecessor for x is top, then the in of s for x is also top. Alright, and this makes sense. It says that if we don&#39;t know whether x is a constant on some path that leads to s, well then, we don&#39;t know that x is a constant at s. Because for all we know, execution came down that particular, came from that particular predecessor and so, we can&#39;t make any prediction about whether s is, whether x is a constant before s executes. Now let&#39;s look at another situation. Let&#39;s say that x is some constant C after the execution of some predecessor. And that on a, after another predecessor a distinct predecessor x is a different constant D. So D is not equal to C. Well then what do we know about x at the program point before s executes? Well, we don&#39;t know anything, x has to be top, because we don&#39;t know which constant, s will be, since we don&#39;t know which path will reach s at run time. And this is the situation that we saw in the example we did by hand. Another possibility is that the predecessors all agree on what the value of x could be. So let&#39;s say that we have, you know, predecessor here and that after it executes x is known to be the constant C and x is known to be the constant C after this predecessor and x is known to be the constant C after this predecessor. There&#39;s one other possibility. Let&#39;s say that after this predecessor over here, all we know is that x is bottom, okay? And so what the rule says is that if we have this situation where either x has the property bottom after a predecessor or all the predecessors agree on the particular constant that x could be, then before at the program point before s executes, we know that x is going to guarantee to be the constant C. And if you think about it for a second, it&#39;s easy to see why this is correct. First of all, clearly if we come along one of the paths where x is known to be the constant C, since they all agree and then when we get to s, x will definitely have the value C. What about the bottom case? Well, remember what that means. That means that this statement is never reached so there&#39;s some predecessor P here which never executes. Which means if P never executes then we could never reach S along this path from P. So the only paths that will reach s are the ones where x is known to be a constant, alright? So that&#39;s why it&#39;s okay in this situation say that x, if control if execution reaches s at all its guaranteed to reach it in a state where x is the constant C. One last possibility is let&#39;s say that x is bottom for all the predecessors, okay? And what does that mean? Well, that means that every predecessor of S never executes so they&#39;re all unreachable. And therefore if every predecessor of x never executes s itself can never execute, and so we can conclude that entry to s, x is bottom. The first four rules that we just looked at relate 

806.12
slide
Constant Propagation Rules 1 4 relate the out of one statement to the in of the next statement Now we need rules relating the in of a statement to the out of the same statement
the out of one statement to the in of the next. We also have to have rules that relate the in of a statement to the out of the same statement. So we have to push information from the input of a statement to the output of the same statement. So, once again, there are several cases. And let&#39;s take a look at an easy one first. If 

826.61
slide
Constant Propagation Rules 1 S C s x out J if C s x in J Mex mm
x is bottom on an entry s, if the program point before s well, that says that at 

831.8
writing

the, that s is never reached, that s never executes. And therefore, x will be bottom after s, after s as well. So if the program point before s is never reached, the program point after s definitely can&#39;t be reached either. Another possibility is that we&#39;re assigning x to constant C in this statement. In that case the out of the statement is going to be equal to C. Alright, so it doesn&#39;t matter what the state of x was before the statement, after we execute the statement, x will be the constant C. And I should say there is a conflict with the previous rule. Okay, it could be that x is bottom, before the statement. So rule six, has lower priority than rule five. So we, so if we could say that x is bottom after the statement, we would prefer you to say that so rule five would be applied first, and then if rule five does not apply. So if x is some other constant D or x = T, then we would apply this rule and we would conclude that x is the constancy afterwards and that makes sense. If x is d or x is the, is top that means that control, as far as we know, can reach this statement. And then what we&#39;re saying here is that well, after the execution of this statement, if control can reach this statement after the execution of it, x is guaranteed to be the constant C. Another possibility is that we have an assignment to x but the right hand side is more complicated than a constant. So this case is for everything other than the constant assignment. Okay, so this F here just stands for some more complicated expression than just a simple constant. And in this case we, we&#39;re just going to say we don&#39;t know what the value is, we&#39;re not going to try to guess what the result of that computation is and we&#39;ll just say that x = T. X, w e don&#39;t know what the value of x is after the execution of this statement. And once again, rule five takes precedence so if rule five applies, then we would apply then, then we would use that rule instead of rule seven. But, if control can reach this statement, so up here x = C or x = T. Then we&#39;ll apply rule seven and conclude that x is top after the statement. And finally Rule eight, another possibility is that we&#39;re assigning to some variable other than x. And in that case, if x = k before the statement then we just keep that value. Okay, so whatever x was before the statement bottom, a constant or top, if the assignment is to some other variable other than x then x will have the same property after the statement executes. Now, we can put these rules together into an algorithm. For 

1000.839
slide
Constant Propagation 1 For every entry 5 to the program set C s x in T 2 Set C s x in C s x out J everywhere else 3 Repeat until all points satisfy 1 8 Pick 5 not satisfying 1 8 and update using the appropriate rule
every entry point, for every entry, statement to the program, we&#39;re going to say on entry that we don&#39;t know anything about the value of x. So the program point 

1009.69
writing

before that entry point we&#39;re gonna say that x has an unknown value, top. And then everywhere else we&#39;re going to say that the value of x, is bottom, okay. And this is actually important so we&#39;re going, what this intuitively is doing is its saying well, as far as we know except for the entry point to the program, which can definitely be executed, we don&#39;t know whether any of the other statements in the control flow graph are actually ever executed and so we&#39;re going to assume initially, that they&#39;re not. And we&#39;re just going to say that x has the value bottom everywhere except at an entry point And now what we&#39;re going to do is a kind of constraint satisfaction algorithm. We&#39;re going to pick some statement that doesn&#39;t satisfy one of the rules, one through eight. And then we&#39;re going to update it using the appropriate rules. So we&#39;ll look for places in the control flow graph where the information is inconsistent according to the rules and then we&#39;ll update, the information to make it consistent with the rules. Let&#39;s take a look at our example again. So, we&#39;re going to start out by saying x = T at the entry 

1079.119
slide
Constant Propagation A 2 X Mex mm
point, and then we&#39;re going to have all of our other program points And let me 

1083.539
writing

indicate them here. Okay, so these are all the other program points that we have to be concerned with. And there again, there&#39;s a program point before and after every statement. And we are going to say the x = bottom for all of these. So, again what this means is, that as far as we know, control doesn&#39;t reach any of these points. We have not yet proven to ourselves that any of these statements can execute. And now we just look around in the program and try to find places, where the information is inconsistent according to the rules, and then we update the information. Let me switch colors here. So, when we begin, the information is consistent everywhere except at this first statement because if x is T before and we&#39;re assigning x to value three. Well, then we should not have x = bottom as the result. In fact this should be x = three. It should be the appropriate information here and once we update that, then we see that this next statement is inconsistent because now we know this statement is reachable. We have a statement here and we&#39;re concluding that the point after is not reachable which is not, not correct according to the rules. So that I believe that this is an application of rule eight. We have a statement here that doesn&#39;t refer to x as and so whatever the value of x was before the statement becomes the value of x after the statement so that becomes x = three. And then, now we can see that this information is inconsistent. The out of the statement here, is not consistent with the in of the statement here. In this case, you know, it&#39;s just one predecessor. And so, the, the value should be the same so x should be three. At this point And similarly x should be three at this point. Here we have an assignment to a variable other than x. That should, information should be the same before and after the statements, same thing here. Now we have an assignment x. The point before that assignment is reachable and so sin ce this is a constant assignment we should know that x is that constant after the assignment. So here again we have a in and out issue so the out of this statement is not consistent with the in of this statement. So this is going to have to be updated but now, what should this be? Well, we have two inconsistent predecessors and so this has to be top and then finally, an assignment to x, sorry, an assignment to a state, to a variable other than x so the information should just propagate across. And that, same is updated like this so now x is known to be top afterwards. And now, if we look around at all the program points, we&#39;d see that all the information is consistent. All the rules, if you, if you, if you check whether the information before and after a statement or across a statement. I&#39;m sorry, or between predecessors and successors is correct, it&#39;s correct everywhere according to the rules and so we&#39;re done. 

