3.73
slide
Compilers 1 Runtime Organization
In this video we&#39;re going to begin our discussion of run time systems. Now, at this point we have actually covered the entire front end of the compiler which 

17.41
slide
Runtime Organization We have covered the front end phases Lexical analysis Parsing Semantic analysis Next are the back end phases Optimization Code generation Alex mm
consists of the three phases, lexical analysis, parsing and semantic analysis 

22.679
writing

And these three passes or these three phases together, their job is to really enforce the language semantics or the language definition. So, we know. After these three phases are done that if no errors have been generated by anyone of those phases then the program is actually a valid program in the programming language that we&#39;re compiling And at this point the compiler is going to be able to produce codes to produce a translation of the program that you can actually execute. And I should say that of course. Enforcing the language definition is just one purpose of the front-end. The front-end also builds the data structures that are needed to do co-generation as we seen but there is a real. Once we get through the front-end we no longer looking for errors in the program. We&#39;re no longer trying to figure out whether it&#39;s a valid program. Now we&#39;re really down to the point where we&#39;re going to generate code And that is a job at the back end. So cogeneration is certainly part of it. The other big part of the back end is program optimization so doing transformations to improve the program. But before we can talk about either one of those things, we need to talk about Runtime organization And why is that, well because we need to understand what it is we&#39;re trying to generate before 

106.63
slide
Runtime Organization Before discussing code generation we need to understand what we are trying to generate There are a number of standard techniques for structuring executable code that are widely used
we can talk about how we generated and have that makes sense. So first, we&#39;re gonna talk about what the, the translator program looks like and how it&#39;s organized and then we&#39;ll talk about algorithms and code generation algorithms were actually producing those things. And this is a well-understood area or at least some very standard techniques that are widely used and those are the ones we wanted to cover and, and encourage you to use in your project. The main thing we&#39;re going to cover in this sequence of videos is the management of Runtime resources and in 

139.489
slide
Runtime Organization Management of run time resources Correspondence between static compile time and dynamic run time structures Storage organization
particular I&#39;m going to be stressing the correspondence and the distinction between 

144.31
writing

static and dynamic structures. So static structures are things that exist to compile time and dynamic structures, those are the things that exist or happen at Runtime And, this is probably the most important distinction for you to try to understand if you really want to understand how a compiler works. What happens to the compile time and what happens at run time. Having a clear separation in your mind between what is done by the compiler and what is deferred to when the target program or the generated program actually runs that is key to really understanding how compilers work. And we&#39;ll also be talking about storage organization. So how memory is used to store the data structures of the executing program. So let&#39;s begin at the beginning. So initially there is the 

199.31
slide
Runtime Organization Execution of a program is initially under the control of the operating system When a program is invoked The OS allocates space for the program The code is loaded into part of the space The OS jumps to the entry point i e main Alex mm
operating system and the operating system is the only thing that is running on the 

202.23
writing

machine and when a program is invoke. When the user says he wants to run a program, what happens while the operating system is going to allocate space for the program the code for the program is going to be loaded into that space and then the operating system is going to execute a job to the entry point or the main function of the program and then your program will be off and running. So, let&#39;s take a look at what the organization memory looks like very roughly when the Operating System 

234.2
slide
Runtime Organization Max tum
began execution of the compiled program. So we&#39;re gonna draw our pictures of memory like this. That would be just a big block and there will be a starting address at the, a lower address and a higher address and this is all the memory that is 

248.969
slide
Runtime Organization Low Address Memory High Address Max Amen
allocated to your program. Now into some portion of that space goes to code for the program so the actual compiled code for the program is loaded usually at one end of the memory space allocated to the program. And then there is a bunch. Of other space that is going to be used for other things and we&#39;ll talk about that in a minute. Before going on, I want to say a few words about this pictures of Run-time 

276.47
slide
Runtime Organization By tradition pictures of machine organization have Low address at the top High address at the bottom Lines delimiting areas for different kinds of data These pictures are simplifications E g not all memory need be contiguous Alex mm
Organization because I&#39;m going to be drawing a lot of them over the next few 

280.84
writing

videos. So, it&#39;s just traditional to have memory drawn as a rectangle with the low address at the top and the high address at the bottom. There&#39;s nothing magic about that, just a convention we could adjust it easily every verse or order of the address, no big deal. And then we&#39;ll be drawing lines to the limit different regions of this memory showing different kinds of data and how they&#39;re stored in the memory allocated to the program. And clearly these pictures are simplifications if this, is a virtual memory system for example, there&#39;s no guarantee that these data is actually laid out contiguously but it helps to understand you know, what the different kinds of data are. And what the, a compiler needs to do with them to have simple pictures like this. So coming back to our picture of run time organization, 

337.58
slide
Runtime Organization Other Space Data Space Compiler is responsible for Generating code Orchestrating use of the data area
we have some block memory and the first portion of that is occupied by the actual 

343.35
writing

generated code for the program and then there was this other space and we&#39;re what goes to that space? Well, what goes to that space is the data for the program. So all the data is in the rest of the space and the tricky thing about code generation that the compiler is responsible for generating the code but it&#39;s also responsible for orchestrating the data. So the compiler has to decide what the lay of the data is going to be and then generate code that correctly manipulates that data so there are references of course in the code. To the data and the code and data need to be designed, the code and the layout of the data, excuse me, need to be designed together so that the generated program will function correctly. Now, it turns out that this actually more than one kind of data that the compiler is going to be interested in and what we&#39;ll be talking about. In the next video is the different kinds of data and the different distinction between the kinds of data that go in this data area. 

